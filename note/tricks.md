典题
===

本文记录简单但经典的思路和技巧。
---

> 算法：二分、递归递推（搜索）、前缀和

<br>
<br>

- 给 $n$ 个区间，每个区间为 $[l_i, r_i]$，问有多少对区间有交集。

<details>

> abc355_d

两个区间 $i, j$ 没有交集，当且仅当 $l_j > r_i$ 或 $l_i > r_j$，即一个区间的左端点大于另一个区间的右端点。

因此对右端点排序。对于每个左端点 $l_i$，二分寻找比它小的右端点的数量，加起来即为没有交集的区间对数量。

或者不分离左右端点，以左端点为关键字排序后，用扫描线扫过去统计。

</details>
<br>

- 给一棵带边权的无根树，求经过所有点至少一次的最短路径（起点终点任意）。

<details>

>abc361_e

如果起点和终点一样，容易想到过程为“出去，再回来”，路径长度为边长和的两倍。

起点终点任意，最优的过程为“出去，到最后一个点停止”，比上述情况少了“从最后一个点回来”的步骤，也就是说，结果为边长和的两倍减去某一条路径的长度。

要使结果最优，减去的路径长度就要最长，显然就是树的直径。

因此两次 dfs 求出直径即可。

</details>
<br>

- 有一座岛，可以看成一个 $n\cdot m$ 的网络，每个格子都有一个给定的高度 $h_{i, j}$。

    刚开始海平面为 $0$，每年上涨 $1$，问 $1, 2, \dots ,A$ 年的时候，岛屿没被海水没过的土地面积（即有多少格子）。

<details>

>abc363_e

每年都搜索一次的复杂度无法接受。

考虑用堆优化。预先将边缘存入一个小根堆中进行 bfs，一年一年看，对于某年海水淹没的所有边缘格子，将他们周围的格子放进堆中。复杂度 $O(n^2 \log (n^2))$ 级别。

详见 [submission](https://atcoder.jp/contests/abc363/submissions/57625023)

</details>
<br>